# Skywave тестовое задание:

![Alt text](/docs/doc.JPG "Предлагаемая архитектура")
## [Ссылка на архитектуру](https://www.draw.io/?title=Untitled%20Diagram.drawio#R7V1tc5u4Fv41mbn3QzxIQrx8tBN7u3M33bbJ3b3dLzsYZJsNRi6QJumvvxIIDEjYxAYTN%2BlMXTggEDrnPHp0dKReoKv10y%2BRs1ndUI8EF1Dzni7Q9QWEQNehzf7lomchgratZaJl5HtCuBXc%2Bj%2BIEOa3PfgeiSs3JpQGib%2BpCl0ahsRNKjIniuhj9bYFDapv3ThLIgluXSeQpX%2F6XrLKpBY0t%2FIPxF%2Bu8jcDQ3zy2slvFl8SrxyPPpZEaHqBriJKk%2Bxo%2FXRFAt5%2Bebtk5WYNV4uKRSRM2hS4pc6fn%2F%2BafV641ipItOBjQO4ugSEqlzznX0w81gDilEbJii5p6ATTrXQS0YfQI%2FyxGjvb3vMbpRsmBEz4D0mSZ6FN5yGhTLRK1oG4ymocPf9PlE9PvvKTEc5Pr5%2FKF6%2BfxVlWV17BxjYQopg%2BRC7Z8eG6sCUnWpJkVwPphaqYmRO6JqxCrGBEAifxv1cr4ghjWxb3bfXBDoRKXqAeUcvvTvAg3iSrKwiYL3C1PK78hNxunPS7H5lHVhvdiTeZgyz8J6480ZrfSZSQp93tKX%2B%2BKKCboojw70toYCuTPJa8RXjAquQouazzJgPWEBbdoWXis7BMfHaWiREa2DLtN4q1xllYtHF2Fq1rA2OtqWgyI2BvnczZwTJJPzwTLCj7ynJjGt8eaH7hMk6td8xu0LXN0%2FZi8RRmkmPAfyc4%2Fb2%2BYO1sZZJpeqylv8X72Pdkr6xWg4lLVaupl%2BkmqeoxTiJ6T65oQCMmCWnIdb%2Fwg6AmcgJ%2FGbJTl%2BmSMPmEa9pnLHIsLqx9zwuaDKfq4x2YCgZ1UzGxObKhhXULmKZmyUgIsMJwcF%2BGY7XwtdAbc%2F6%2BbWTPiVdpK4He%2Bt4mBCo11K52ag1U4g2fqJ96hVCbaRo1tQHbqj4k%2BwJRrkz29z0KYav2qAyOpUel%2Biw%2B%2FXAV243YcCQUSAjDvMYep0iQHk8sCSeg2v0bkOJnRQUAJfsydbkH0RUGDvsCAqga4bzMTKDSTH4NY9ZWPPTgJA4f%2BEd0zf65JWFMo7it7k%2FAz8p2cwGRh4nl6ZKRsSsWnCPD6Bjv8pDKPmqWAfRgw%2BC3ypzb68ceUj95NY%2FwYgSbeJ89TZEc5CyPHWu5pGB%2FMP01S%2FjPH9qONmbH7Be2hYWqae0ZC3SC3EBiBprM4RA66XDWfKtO2Tp22KDVEzllc9c6jyQ2FTX3gQcPemtd22KxgK6r6to8Y25goxtfMQ1UcxVV4AdiBcnBfWlCFSw7RBM9DIkODsoMNCQCmolGtm2bGFvYRmZNZwePj7ZU%2BETjI9hsFMcx32sSkISwy9cZ82Ve6654bWL%2BcUFEHI%2Frzw%2B59lelG6%2ByYcrrocZbrN%2FC%2B9cKuquxPj37RCKf6YiPu1JhHYwsl6jBaG5hHb%2Bsy%2BifPqutGCBLinJj1MojOjNjrU%2FqNymxs3GJ%2Bk1S7nZV4nTZnYwFazef7%2B4E97NnpfJ6%2BjvLKWLGA2XS%2BFoZoNZmpg0ZCigGoLfRO3wFys%2FkTDLLtZ7ye1tvq8s8KvObMyfBJxr7iU95dGZOk4Suq6qsR3ASDmVyoGdvhIjhjKZNpjPIb145G16V9dOSp1GMnB8PERnF34K%2Feexi7qTcqwsbQlAf4ZoV6Ui2IgCQwop6CwbrvVmReIq%2FFcwS1juKas%2FcwOdNB2ecoBW24teLn3FP2L4L2zvqgVbbvk7baYWX2ggall01Q%2F0gtsjIsPNcumHDO7m4ubtEwKy9FxqmtZMnKnrYWhF2kNWj9oC8UnSxiEkvXS9uZpDxxgmP8RsGpfJv4Q3Z01%2BDNwwWA2jtDXjQGABUTbRlelyBbqdoBe2afPn9P9Mv%2B2dh5dd7%2FveOJ40bx9jN1VJUQiFq617Nk9n7mWlBd64FrSm4jjiFpTtxKszioMVjZxVimx1Dbf0tSRp9Wd0ONQ9XTIgx6uuHS3aGt2d3qTfz7kBNkCkjM4sgjWasfM8joQQNUvyIGA3xI9Oea7zEMnDiWJR26dp3xXGRe9nRVBq0tHr8wNB1iUiZuaxMpHSzNyLVWxi%2BsSt4PcSo2hWYp%2BwL7LbMyBqyL0CqBKeqdeTZ17n%2BwU5O3cKa8Itx%2BcXs%2B3VMz1cApgmFugAeXZoJQtbAc%2Fh6cxqYqnc5Gor2D%2BEaOvfXyVuLKydIem%2BbiXn0dPJB4zM22NKrxg1svGd8Zlv1CYKXFykmTpVDuq6Ga%2Fp%2B%2FD2KeYsVMDx2BbUPTsigq3Uw%2F0XhzFNhnRzzBDaAEtYhw5TBDuSW1H3ie3PAe%2FDJvJZUZajJPOZ60mzeoQmOTMNm9VnIQKedwcNvde0UbjvthYddotI8HPqZEyCQhev9mw5kinjSDAgDvlVXaZsrhAcdG%2BY5M%2Be7aK5tOxsNsxMnamf93Q%2F2%2BMGgiax5NbtftVDJRC3yTmFFcs5kXQdQioiqlgKr1qfpvU0t56HWgfwNDOdvbeenjGP7nYNG%2BobCWsDuYbtcxNoxD9sZx2%2BxUi3P3%2FDX6V4Sk735JAG%2FMHHc%2B2VqalWGyP4oQpEiz6ROMNNXjnOplkvY8SpJ%2BA4Z4zRcP3vYBNTxRo%2F%2Bvb8mnu%2BMaLRkYn6%2B4ec8kkbXaxoync00%2Fpewn6vAd%2B9X9CEmow2f3elkaSLS6nPwpq3laSmVYT2QkQLlQZTukWJghjqy2Ui4ihYm2oMXyjzHLkGk7cSGYQwBItiUYn%2BWyIloAhFFEaCdAkZUqyHfYeQoGKmn%2BWvQegUwAiS9vg3CkSee7scKcxCssPU64YBi3rYRK6QiBsAXvUOFoYovv0NFp1Cha3BooMjf1stIs7IcXivlutfGm1opQ8i8qKQZ4VJ20biUVFROvh6XMpZ4BlKqvQ9ce%2BzkX9JjJkUOUjV1u8iAmv77fdJfvZ2HUQcvW7H8U7cVY%2Bveko0M1XTm%2BeEUCd3oeZMQ7zKZh9poGSesF3JHLt8tYJYWYffOvvEXzdnrxuOPnv2Le%2BvdhNr0w5c7b23%2BDu3nf%2Fybuyv469834bcf9zf2x5X97N%2F%2FYWPzL%2BdrdHlj%2Fvf2j47QTDfraAaQKduCjRUp%2FLrRmzGoUkDejaF%2FY6hv9GPpWEGCT20NP0fQ5PytASnm%2FU5sCzk2lWzhjnfeb7tHRwDgkWHbpsbgHMDaoixdz3P1hkrpM4%2BfB9m9JGtemRjRSlt0zKSdnMYlGmuUKGe%2B3k%2BwxzKrLNaEZsz0qnrnRFV8WnovKm0QAqrbhBQLRq9LpfL7RRI%2BlrYquS59zqT0CXae0n%2Fu21OdbJrJMmoYB3RTBjmsymLqbxOr5r3OfuZEEwikTRQQHnirDbM5yXLw7LyDs27fs%2FMOsYQdm5MOawmNDnWpjTRJCbJD9WgDyMrnwbbzI%2FV9UdraALLqUQtk1O2pwQa6WUXLTre762e3b%2F%2BbAjT9Pw%3D%3D)

Что бы разобраться в моем решении - предлагаю описать все компоненты, начиная с малых и постепенно передвигаться к картине целиком:
Самыми маленькими элементами в системе являются сенсоры, подключенные к клиенту

## Сенсоры

В качестве сенсора в моем проекте присутствуют 3 эмулятора:
```
tempertature_emulator.py
pressure_emulator.py
height_emulator.py
```
Каждый из них эмулирует работу сенсоров, генерируя рандомный числа

## Клиент:

Каждый клиент состоит из 3 частей:
- Обработчик сенсоров
- MQTT - подписчик
- Обработчик подключений
- Локальная БД

### Обработчик сенсоров:
```
./client/emitter_listener.py
```
В качестве связи между обработчиком и сенсорами я решил выбрать сокеты, что бы обеспечить бесперерывную связь.
При каждом получении новых данных, обработчик засовывает эти данные сперва в локальную БД.
После того, как данные записаны в БД обработчик передает их по MQTT брокеру с топиком `'/telemetry/client/{client_id}'`, где  `client_id` - переменная.


### Локальный MQTT подписчик:
```
./client/local_mqtt_subscriber.py
```
MQTT подписчик слушает топики которые относятся к его `client_id`, что бы удостовериться, что данные доставлены до сервера.
После того, как подписчик получает новое сообщение от mqtt-broker'a - он удаляет эти данные из локальной БД, так как они больше не нужны


### Обработчик подключений
Так как одним из требований была надежность передачи данных от клиента серверу - Обработчик подключений, при подключении к mqtt хосту отправляет все данные, которые есть в локальной БД.
После того, как эти же данные возвратятся локальному mqtt подписчику - они будут удалены из БД и следующий раз не отправятся при сбое-подключении к mqtt-хосту

## Сервер:
На сервере все просто, там висит глобальный mqtt подписчик, который подписан на все топики и сохраняет все сообщения в базу данных
- global_mqtt_subscriber.py

## О выбраном стеке технолгий:

### Протокол передачи данных
Если бы не примечание про то, что каждый клиент отправляет в среднем 1000 сообщений в секунду - я бы выбрал обычнй паттерн http (request <-> response)
Но так как http для таких объемов запросов был бы избыточным и быстро забил бы канал - я решил остановится на mqtt, хотя так же рассматривал amqp
MQTT выглядит самым приемлемым вариантом

### Базы данных

#### Локальная
В качестве локальной базы даных - мною выбран postgres (облегченной версии). Основынм критериеми, которыми я руководствовался были:
- ACID
- Быстрая вставка, быстрое удаление (без индексов)

По этим критериям подходят многие БД, но я решил использовать postgres.
Если бы не примечание про то, что клиент может периодически выключаться - я бы выбрал любую из in memory database
Возможно, локальную БД можно заменить на mongoDB. Нужно провести тесты

#### Глобальная
в качестве глобальной БД - я выбрал ClickHouse, так как она идеально подходит для этих целей:
- Быстрая вставка
- Быстрый select (для мониторинга и аналитики)

В качестве альтернативы ClickHouse можно выбрать любую БД, которая хорошо работает с timeseries (InfluxDB, TimescaleDB и тд).
Опять же, нужно провести тесты и выявить победителя

## Язык программирования
Проект реализован на python, так как я невнимательно прочитал ТЗ и понял, что проект нужно еще и написать, а не только разрисовать, когда у меня осталось 2 дня до сдачи
Для боевых условий я бы использовал другой язык, точно не интерпретируемый. Либо Go, Rust или C/C++.
Опять же, нужно провести замеры для команды, какой язык для них самый оптимальный

## Масштабируемость
Для того, что бы данные точно не потеялись из глобальной ДБ - предлагаю делать репликацию в Hadoop, так как его файловая система идеальная для масштабирования и поддержки жестких дисков.
Если все кластеры с ClickHouse полетят - то их можно будет заново заполнить дампами из Hadoop

## Окестрация, CI/CD
Для того что бы любой из клиентов можно было удаленно отладить, перезагрузить, заменить ПО - предлагаю использовать связку Kubernetes и Docker. 
Главное правильно расставить лэйблы всем контейнерам, иначе - очень легко запутаться из-за большого количества клиентов

## Install project
```sh
git clone https://github.com/sharkaev/skywave.git
cd skywave

# Собрать контейнеры из docker
docker-compose up
# По умолчанию я отключл запись volume'ов на диск, но можно раскоментировать эти строки в docker-compose.yml
# Запуск сервера
py ./server/global_mqtt_subscriber.py

# Запуск эмулятора
py ./emulators/temperature_emulator.py

# Запуск Клиента
py ./client/app.py

# Если app.py не запустит 2 отдельных окна - прервать Ctrl + C
# и выполнить вручную запуск local_mqtt_subscriber и emitter_listener
py ./client/local_mqtt_subscriber.py
py ./client/emitter_listener.py
```
